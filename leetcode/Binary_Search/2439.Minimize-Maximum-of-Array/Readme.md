### 2439.Minimize-Maximum-of-Array

本题的大体思路就是，如果有一个数字特别大，那么我们希望它能与之前的数字们一起“抹匀”，来尽量减少最大值。由于更靠前的数字，只能与更少数量的伙伴一起“抹匀”，所以最终呈现出来的最优解形态，应该是piece-wise constant的递减数列。这个数列的第一个元素的大小，就是最终答案。

#### 解法1：二分搜值

那么这个数字最小是什么呢？并不太容易直接求出来。但是如果我们猜测一个，是容易判断它是否成立的。

我们首先猜测最终答案是x。明显，这个x必然不会小于nums[0]，因为nums[0]没有机会向前分摊数值。如果x>nums[0]，那么这意味着后面的元素有机会向nums[0]分摊一些数值，我们记做“缓冲值”：`buff = x-nums[0]`. 

接下来我们看nums[1]。如果`nums[1]>x`，那么不得不让它往前分摊数值，最多能够分摊多少呢？显然就是buff。于是如果`buff> nums[1]-x`，那么就OK，同时`buff-=nums[1]-x`；否则就直接返回失败。反之，如果`nums[1]<x`，同样意味着后面的元素有机会往前分摊数值，这部分分摊可以均匀承担在nums[0]与nums[1]上，所以`buff+= x-nums[1]`。

由此可见，我们需要做的就是不停的比较x与nums[i]，根据孰大孰小和增加或者减少buffer。当buffer降为0以下的时候，说明无法实现前面若干个元素“抹匀”成x（或更小），返回失败。否则返回成功。

通过二分搜值的讨论，我们可以很容易求出满足条件的最小值。

注意本题一定有解（什么都不做就可以返回数组最大值），因此二分搜值的收链解就是最优解。

#### 解法2：贪心
本题有直接的贪心策略。我们考虑前i个元素，最优的方案就是将前i个元素的和均匀分配，那么分配之后的最大值就是`ceil(presum[i]/i)`（假设是1-index）。我们考察所有的i，得到的全局最大值就是答案。

这种贪心策略看上去并不“严谨”。比如说，如果nums[i]相比于之前的所有元素都小，那么我们其实是无法做到让前i个元素均匀分配的。但是这种情况下，意味着前i-1个元素的均匀分配会产生更大的数值，那个数值会overwirte掉最终的答案，而使得“前i个元素均匀分配”这种实际上无法实现的策略不会干扰最终答案。
